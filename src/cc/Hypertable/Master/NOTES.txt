
TODO:
- Remove Close
- Remove Shutdown
- MasterClient
- soft_limit
- add is_split to RSML load_range
- add state to facilitate balancing?
- Remove this file

DONE:
- Add Monitoring
- Add GC
- Cache property maps in the context (op)
- Add COMPLETE operation heap & make sure COMPLETED ops don't get added on restart
- Relinquish Acknowledge
- Drop table (dependencies: other table ops, participating range servers, root?)
- Alter table (dependencies: other table ops & participating range servers)
- METADATA table needs to be opened in the Master
- Get schema (dependencies: other table ops)
- Move range (dependencies: table ops? root?)
- Add OperationSystemUpgrade (METADATA and RS_METRICS schema upgrade)
- Create namespace (dependencies: other namespace ops)
- Drop namespace (dependencies: other namespace ops)
- Register Server 
- Create table (dependencies: other table ops, participating range servers, root?)
  - create-table-in-hyperspace
  - create-table-write-metadata
  - create-table-load-range
Add creation of attribute "x" to CreateTable
- Initialize
- all ops should be dependent on INITIALIZE
- Rename table (dependencies: other table ops)


- server-joined
- server-left
- wait-for-root



move_range operations should take precedence over other operations

alter_table and move_range need to both have exclusivity on the table

Things to handle:

- There are some operations which are higher priority than the others, should we handle this through dependencies?
- 
Should we have register server implemented as an opar
- Initialization needs to wait for servers
- Operation needs to inform oee that it is ready for continued processing
- Implement "wake up" Interface for oee and pass into each operation
- Have execute() return false if not finished
- Maybe create_table and initialize can be implemented as a set of dependent operations
- Maybe have a current execution set
  - When set becomes empty, compute next group
  - oee threads block until current execution set becomes empty

- Things to be depenedent on:
  1. Specific servers
  2. Specific names
  3. The joining of at least one server
  4. METADATA
  5. Hyperspace


OperationExecutionEngine
  - server_left - if any operations are dependent on that server, create wait-for-server operation
  - server_joined - if wait-for-server operation outstanding, remove it
  - wake up - signal oe thread condition variable


OperationCreateTableHyperspace
OperationCreateTableLoadRange
OperationCreateTableWriteMetadata


  - create-table-load-range(ROOT)
  - create-table-write-metadata(2nd level METADATA)


Graph Operations:
- server-joined
- server-left
- wait-for-root
- wait-for-server?
- Initialize (dependencies: registered server, wait-for-root)
  - create-namespace(sys)
  - create-table-in-hyperspace(METADATA)
  - create-table-load-range(ROOT)
  - create-table-write-metadata(2nd level METADATA)
  - create-table-load-range(2nd level METADATA)
  - create-table(sys/RS_METRICS)
- Register Server 
- Create table (dependencies: other table ops, participating range servers, root?)
  - create-table-in-hyperspace
  - create-table-write-metadata
  - create-table-load-range
- Drop table (dependencies: other table ops, participating range servers, root?)
- Alter table (dependencies: other table ops & participating range servers)
- Rename table (dependencies: other table ops)
- Get schema (dependencies: other table ops)
- Move range (dependencies: table ops? root?)
- Relinquish Acknowledge
- Create namespace (dependencies: other namespace ops)
- Drop namespace (dependencies: other namespace ops)



TODO:
1. Get basic Operation Execution Engine built
2. Implement CREATE TABLE operation in new model


Graph Operations:
  - When server leaves, insert recover_server operation.
    - Halt execution
    - Scan existing vertices and make the ones that are dependent on that server, dependent on the recover_server operation
    - Re-compute ExecutionOrder
    - Resume Execution
    - Execution threads will skip recover_server operations
  - When server joines
    - Halt execution
    - Find corresponding reccoer_server operation
      - Clear delay timer for dependent operations
      - Remove recover_server operation
    - Re-compute ExecutionOrder
    - Resume Execution
  - Table operation
    - Determine dependent servers, persist state
    - Halt execution
    - Make operation dependent on latest outstanding operation for same table
    - Re-compute ExecutionOrder
    - Resume Execution
  - Table operation - partial execution
    - Halt execution
    - persist state with remaining server dependencies
    - Set operation delay timer to X seconds to give system a chance to recover
    - Re-compute ExecutionOrder
    - Resume Execution
    - Execution threads will wait until delay timer expires before proceeding with operation
  - Range operation
    - Halt execution
    - Find recover_server operation for dependent server, if exist make this operation dependent on it
    - Re-compute ExecutionOrder
    - Resume Execution
  - Namespace operation
    - Halt execution
    - Make operation dependent on latest outstanding operation for same namespace
    - Re-compute ExecutionOrder
    - Resume Execution
    
    
Operations have dependencies:
 - RangeServers
 - Other operations
 - Ranges

Each operation should advertise the tables it is dependent on.
When an operation is created, it should become dependent on 

COMMAND_CREATE_TABLE:
  1. write entry into METADATA
  2. pick range server
  3. load  range
  Dependencies:  other table ops, namespace ops, range server after step 2

COMMAND_DROP_TABLE:
  1. Scan metadata to find servers
  2. Issue drop table requests to servers
  Dependencies:  other table ops, namespace ops, range servers after step 1

COMMAND_ALTER_TABLE:
  1. Scan metadata to find servers
  2. Issue drop table requests to servers
  Dependencies:  other table ops, namespace ops, range servers after step 1

COMMAND_RENAME_TABLE:

COMMAND_GET_SCHEMA:

COMMAND_STATUS:

COMMAND_REGISTER_SERVER:

COMMAND_MOVE_RANGE:

COMMAND_RELINQUISH_ACKNOWLEDGE:

COMMAND_CLOSE:

COMMAND_SHUTDOWN:

COMMAND_CREATE_NAMESPACE:

COMMAND_DROP_NAMESPACE:



